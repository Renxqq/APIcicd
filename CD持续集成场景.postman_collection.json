{"info":{"_postman_id":"19ac2150-9eff-4bab-b12a-f66704061736","name":"TestCI/CD持续集成场景","schema":"https://schema.getpostman.com/json/collection/v2.1.0/collection.json"},"item":[{"name":"创建订单接口","request":{"method":"POST","url":"https://api.xlwms.com/openapi/v1/outboundOrder/create","header":[{"key":"Content-Type","value":"application/json"}],"body":{"mode":"raw","raw":"{\n    \"appKey\": \"b80bf9a79fba4efd9fe7a1ffd8591116\",\n    \"data\": [\n        {\n            \"subOrderType\": 1,\n            \"receiver\": \"xgb\",\n            \"logisticsChannel\": \"No_Shipping_Service\",\n            \"provinceCode\": \"AL\",\n            \"contactName\": \"xgb\",\n            \"companyName\": \"yuhu\",\n            \"telephone\": \"12133434545\",\n            \"countryRegionCode\": \"US\",\n            \"referOrderNo\": \"ccc\",\n            \"thirdOrderNo\": \"ccc\",\n            \"cityName\": \"sdf\",\n            \"countryRegionName\": \"United States of America (USA)\",\n            \"whCode\": \"WH2222\",\n            \"addressTwo\": \"\",\n            \"postCode\": \"213544\",\n            \"addressName\": \"宇宙\",\n            \"provinceName\": \"Alabama\",\n            \"addressOne\": \"个人体验体验让他热热\",\n            \"email\": \"er4t@12.com\",\n            \"houseNum\": \"\",\n            \"productList\": [\n                {\n                    \"quantity\": 10,\n                    \"fnsku\": \"\",\n                    \"availableAmount\": 3617,\n                    \"productAliasName\": \"old-lml-sku003\",\n                    \"sku\": \"old-lml-sku003\",\n                    \"skuId\": \"1001069old-lml-sku003\",\n                    \"productName\": \"old-lml-sku003\"\n                },\n                {\n                    \"quantity\": 10,\n                    \"fnsku\": \"\",\n                    \"availableAmount\": 3617,\n                    \"productAliasName\": \"old-lml-sku003\",\n                    \"sku\": \"old-lml-sku003\",\n                    \"skuId\": \"1001069old-lml-sku003\",\n                    \"productName\": \"old-lml-sku003\"\n                }\n            ],\n            \"orderExtensionInfoBO\": {\n                \"platformOrderId\": \"TK平台订单ID\",\n                \"platformPackageId\": \"TK平台包裹ID\"\n            }\n        }\n    ],\n    \"reqTime\": \"1653363592\"\n}","options":{"raw":{"language":"json"}}}},"events":[{"listen":"prerequest","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        // 引入加密库\r\nconst CryptoJS = require('crypto-js');\r\n\r\n// 配置参数\r\nconst appKey = \"816ad7a730484c4596cafb1e42371218\";\r\nconst appSecret = \"fc34184c6350441ba1a5509d74b32d39\";\r\n\r\n// 生成当前秒级时间戳\r\nconst reqTime = Math.floor(Date.now() / 1000);\r\n\r\n// 设置 reqTime 到环境变量\r\npm.environment.set(\"reqTime\", reqTime);\r\n\r\n// 获取并更新请求体数据 - 只更新 reqTime，不修改 data\r\nfunction getAndUpdateRequestBody() {\r\n    try {\r\n        // 获取原始请求体\r\n        const rawBody = pm.request.body?.raw;\r\n        let requestBody = {};\r\n        \r\n        if (rawBody) {\r\n            requestBody = JSON.parse(rawBody);\r\n        }\r\n        \r\n        // 只更新顶层的 reqTime 字段，不修改 data 内的内容\r\n        requestBody.reqTime = reqTime;\r\n        \r\n        // 更新请求体\r\n        pm.request.body.update(JSON.stringify(requestBody, null, 2));\r\n        \r\n        console.log(\"更新后的请求体:\", JSON.stringify(requestBody, null, 2));\r\n        \r\n        return requestBody;\r\n    } catch (e) {\r\n        console.error(\"处理请求体时出错:\", e);\r\n        return { reqTime: reqTime };\r\n    }\r\n}\r\n\r\n// 递归对对象的所有属性按字典序排序（不区分大小写）\r\nfunction sortObjectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        // 如果是数组，对每个元素进行排序\r\n        return obj.map(item => sortObjectKeys(item));\r\n    } else if (obj && typeof obj === 'object') {\r\n        // 如果是对象，对键进行排序并递归处理值\r\n        const sortedKeys = Object.keys(obj).sort((a, b) => {\r\n            return a.toLowerCase().localeCompare(b.toLowerCase());\r\n        });\r\n        \r\n        const sortedObj = {};\r\n        sortedKeys.forEach(key => {\r\n            sortedObj[key] = sortObjectKeys(obj[key]);\r\n        });\r\n        \r\n        return sortedObj;\r\n    }\r\n    \r\n    // 基本类型直接返回\r\n    return obj;\r\n}\r\n\r\n// 处理 data 数据 - 如果有值则按字典序排序，否则使用 {}\r\nfunction processData(requestBody) {\r\n    // 检查 data 是否存在且有值\r\n    if (requestBody.data && \r\n        (Array.isArray(requestBody.data) && requestBody.data.length > 0) ||\r\n        (typeof requestBody.data === 'object' && Object.keys(requestBody.data).length > 0)) {\r\n        \r\n        // 对 data 进行深度排序\r\n        const sortedData = sortObjectKeys(requestBody.data);\r\n        \r\n        // 将排序后的 data 对象转换为字符串\r\n        const dataStr = JSON.stringify(sortedData);\r\n        console.log(\"排序后的 data:\", dataStr);\r\n        \r\n        return dataStr;\r\n    } else {\r\n        // data 为空或不存在，使用 {}\r\n        console.log(\"data 为空，使用 {}\");\r\n        return \"{}\";\r\n    }\r\n}\r\n\r\n// 生成 authcode 的主函数\r\nfunction generateAuthCode(dataStr) {\r\n    // 构建待加密字符串: appKey + data + reqTime\r\n    const signString = appKey + dataStr + reqTime.toString();\r\n    console.log(\"最终待加密字符串:\", signString);\r\n    \r\n    // 使用 appSecret 作为密钥进行 HMAC-SHA256 加密\r\n    const authCode = CryptoJS.HmacSHA256(signString, appSecret).toString(CryptoJS.enc.Hex);\r\n    console.log(\"生成的 authCode:\", authCode);\r\n    \r\n    return authCode;\r\n}\r\n\r\n// 解析 URL 的辅助函数（兼容 Apifox 环境）\r\nfunction parseUrl(urlString) {\r\n    // 简单的 URL 解析函数，用于 Apifox 环境\r\n    const urlMatch = urlString.match(/(https?:\\/\\/[^\\/]+)(\\/.*)?/);\r\n    if (!urlMatch) {\r\n        throw new Error('Invalid URL format');\r\n    }\r\n    \r\n    const baseUrl = urlMatch[1];\r\n    const pathAndQuery = urlMatch[2] || '';\r\n    \r\n    // 分离路径和查询参数\r\n    const pathQueryMatch = pathAndQuery.split('?');\r\n    const path = pathQueryMatch[0] || '';\r\n    const queryString = pathQueryMatch[1] || '';\r\n    \r\n    // 解析查询参数\r\n    const queryParams = {};\r\n    if (queryString) {\r\n        queryString.split('&').forEach(param => {\r\n            const [key, value] = param.split('=');\r\n            if (key) {\r\n                queryParams[decodeURIComponent(key)] = decodeURIComponent(value || '');\r\n            }\r\n        });\r\n    }\r\n    \r\n    return {\r\n        baseUrl,\r\n        path,\r\n        queryParams\r\n    };\r\n}\r\n\r\n// 构建 URL 的辅助函数\r\nfunction buildUrl(baseUrl, path, queryParams) {\r\n    let url = baseUrl + path;\r\n    \r\n    const queryString = Object.keys(queryParams)\r\n        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)\r\n        .join('&');\r\n    \r\n    if (queryString) {\r\n        url += '?' + queryString;\r\n    }\r\n    \r\n    return url;\r\n}\r\n\r\n// 主执行逻辑\r\ntry {\r\n    // 获取并更新请求体（只更新 reqTime）\r\n    const requestBody = getAndUpdateRequestBody();\r\n    \r\n    // 处理 data 数据\r\n    const dataStr = processData(requestBody);\r\n    \r\n    // 生成 authcode\r\n    const authCode = generateAuthCode(dataStr);\r\n    \r\n    // 设置环境变量\r\n    pm.environment.set(\"authCode\", authCode);\r\n    \r\n    // 关键修复：使用兼容 Apifox 的 URL 处理方法\r\n    const currentUrlString = pm.request.url.toString();\r\n    console.log(\"原始 URL:\", currentUrlString);\r\n    \r\n    // 解析当前 URL\r\n    const urlParts = parseUrl(currentUrlString);\r\n    \r\n    // 添加或更新 authcode 参数\r\n    urlParts.queryParams.authcode = authCode;\r\n    \r\n    // 构建新的 URL\r\n    const newUrl = buildUrl(urlParts.baseUrl, urlParts.path, urlParts.queryParams);\r\n    \r\n    // 更新请求 URL\r\n    pm.request.url = newUrl;\r\n    \r\n    console.log(\"=== authcode 生成完成 ===\");\r\n    console.log(\"新生成的 reqTime:\", reqTime);\r\n    console.log(\"处理后的 data:\", dataStr);\r\n    console.log(\"authCode:\", authCode);\r\n    console.log(\"目标 URL:\", newUrl);\r\n    \r\n} catch (error) {\r\n    console.error(\"生成 authcode 时出错:\", error);\r\n    // 提供更详细的错误信息\r\n    console.error(\"错误堆栈:\", error.stack);\r\n}\n      "],"type":"text/javascript"}}],"protocolProfileBehavior":{"disableBodyPruning":true}},{"name":"取消/截单小包出库单","request":{"method":"POST","url":"https://api.xlwms.com/openapi/v1/outboundOrder/cancel","header":[{"key":"Content-Type","value":"application/json"}],"body":{"mode":"raw","raw":"{\n    \"appKey\": \"816ad7a730484c4596cafb1e42371218\",\n    \"reqTime\": \"{{reqTime}}\",\n    \"data\": [],\n    \"outboundOrderNoList\": [\n        \"OBS069220720000\",\n        \"OBS069220720001\"\n    ]\n}","options":{"raw":{"language":"json"}}}},"events":[{"listen":"prerequest","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        // 引入加密库\r\nconst CryptoJS = require('crypto-js');\r\n\r\n// 配置参数\r\nconst appKey = \"816ad7a730484c4596cafb1e42371218\";\r\nconst appSecret = \"fc34184c6350441ba1a5509d74b32d39\";\r\n\r\n// 生成当前秒级时间戳\r\nconst reqTime = Math.floor(Date.now() / 1000);\r\n\r\n// 设置 reqTime 到环境变量\r\npm.environment.set(\"reqTime\", reqTime);\r\n\r\n// 获取并更新请求体数据 - 只更新 reqTime，不修改 data\r\nfunction getAndUpdateRequestBody() {\r\n    try {\r\n        // 获取原始请求体\r\n        const rawBody = pm.request.body?.raw;\r\n        let requestBody = {};\r\n        \r\n        if (rawBody) {\r\n            requestBody = JSON.parse(rawBody);\r\n        }\r\n        \r\n        // 只更新顶层的 reqTime 字段，不修改 data 内的内容\r\n        requestBody.reqTime = reqTime;\r\n        \r\n        // 更新请求体\r\n        pm.request.body.update(JSON.stringify(requestBody, null, 2));\r\n        \r\n        console.log(\"更新后的请求体:\", JSON.stringify(requestBody, null, 2));\r\n        \r\n        return requestBody;\r\n    } catch (e) {\r\n        console.error(\"处理请求体时出错:\", e);\r\n        return { reqTime: reqTime };\r\n    }\r\n}\r\n\r\n// 递归对对象的所有属性按字典序排序（不区分大小写）\r\nfunction sortObjectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        // 如果是数组，对每个元素进行排序\r\n        return obj.map(item => sortObjectKeys(item));\r\n    } else if (obj && typeof obj === 'object') {\r\n        // 如果是对象，对键进行排序并递归处理值\r\n        const sortedKeys = Object.keys(obj).sort((a, b) => {\r\n            return a.toLowerCase().localeCompare(b.toLowerCase());\r\n        });\r\n        \r\n        const sortedObj = {};\r\n        sortedKeys.forEach(key => {\r\n            sortedObj[key] = sortObjectKeys(obj[key]);\r\n        });\r\n        \r\n        return sortedObj;\r\n    }\r\n    \r\n    // 基本类型直接返回\r\n    return obj;\r\n}\r\n\r\n// 处理 data 数据 - 如果有值则按字典序排序，否则使用 {}\r\nfunction processData(requestBody) {\r\n    // 检查 data 是否存在且有值\r\n    if (requestBody.data && \r\n        (Array.isArray(requestBody.data) && requestBody.data.length > 0) ||\r\n        (typeof requestBody.data === 'object' && Object.keys(requestBody.data).length > 0)) {\r\n        \r\n        // 对 data 进行深度排序\r\n        const sortedData = sortObjectKeys(requestBody.data);\r\n        \r\n        // 将排序后的 data 对象转换为字符串\r\n        const dataStr = JSON.stringify(sortedData);\r\n        console.log(\"排序后的 data:\", dataStr);\r\n        \r\n        return dataStr;\r\n    } else {\r\n        // data 为空或不存在，使用 {}\r\n        console.log(\"data 为空，使用 {}\");\r\n        return \"{}\";\r\n    }\r\n}\r\n\r\n// 生成 authcode 的主函数\r\nfunction generateAuthCode(dataStr) {\r\n    // 构建待加密字符串: appKey + data + reqTime\r\n    const signString = appKey + dataStr + reqTime.toString();\r\n    console.log(\"最终待加密字符串:\", signString);\r\n    \r\n    // 使用 appSecret 作为密钥进行 HMAC-SHA256 加密\r\n    const authCode = CryptoJS.HmacSHA256(signString, appSecret).toString(CryptoJS.enc.Hex);\r\n    console.log(\"生成的 authCode:\", authCode);\r\n    \r\n    return authCode;\r\n}\r\n\r\n// 解析 URL 的辅助函数（兼容 Apifox 环境）\r\nfunction parseUrl(urlString) {\r\n    // 简单的 URL 解析函数，用于 Apifox 环境\r\n    const urlMatch = urlString.match(/(https?:\\/\\/[^\\/]+)(\\/.*)?/);\r\n    if (!urlMatch) {\r\n        throw new Error('Invalid URL format');\r\n    }\r\n    \r\n    const baseUrl = urlMatch[1];\r\n    const pathAndQuery = urlMatch[2] || '';\r\n    \r\n    // 分离路径和查询参数\r\n    const pathQueryMatch = pathAndQuery.split('?');\r\n    const path = pathQueryMatch[0] || '';\r\n    const queryString = pathQueryMatch[1] || '';\r\n    \r\n    // 解析查询参数\r\n    const queryParams = {};\r\n    if (queryString) {\r\n        queryString.split('&').forEach(param => {\r\n            const [key, value] = param.split('=');\r\n            if (key) {\r\n                queryParams[decodeURIComponent(key)] = decodeURIComponent(value || '');\r\n            }\r\n        });\r\n    }\r\n    \r\n    return {\r\n        baseUrl,\r\n        path,\r\n        queryParams\r\n    };\r\n}\r\n\r\n// 构建 URL 的辅助函数\r\nfunction buildUrl(baseUrl, path, queryParams) {\r\n    let url = baseUrl + path;\r\n    \r\n    const queryString = Object.keys(queryParams)\r\n        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)\r\n        .join('&');\r\n    \r\n    if (queryString) {\r\n        url += '?' + queryString;\r\n    }\r\n    \r\n    return url;\r\n}\r\n\r\n// 主执行逻辑\r\ntry {\r\n    // 获取并更新请求体（只更新 reqTime）\r\n    const requestBody = getAndUpdateRequestBody();\r\n    \r\n    // 处理 data 数据\r\n    const dataStr = processData(requestBody);\r\n    \r\n    // 生成 authcode\r\n    const authCode = generateAuthCode(dataStr);\r\n    \r\n    // 设置环境变量\r\n    pm.environment.set(\"authCode\", authCode);\r\n    \r\n    // 关键修复：使用兼容 Apifox 的 URL 处理方法\r\n    const currentUrlString = pm.request.url.toString();\r\n    console.log(\"原始 URL:\", currentUrlString);\r\n    \r\n    // 解析当前 URL\r\n    const urlParts = parseUrl(currentUrlString);\r\n    \r\n    // 添加或更新 authcode 参数\r\n    urlParts.queryParams.authcode = authCode;\r\n    \r\n    // 构建新的 URL\r\n    const newUrl = buildUrl(urlParts.baseUrl, urlParts.path, urlParts.queryParams);\r\n    \r\n    // 更新请求 URL\r\n    pm.request.url = newUrl;\r\n    \r\n    console.log(\"=== authcode 生成完成 ===\");\r\n    console.log(\"新生成的 reqTime:\", reqTime);\r\n    console.log(\"处理后的 data:\", dataStr);\r\n    console.log(\"authCode:\", authCode);\r\n    console.log(\"目标 URL:\", newUrl);\r\n    \r\n} catch (error) {\r\n    console.error(\"生成 authcode 时出错:\", error);\r\n    // 提供更详细的错误信息\r\n    console.error(\"错误堆栈:\", error.stack);\r\n}\n      "],"type":"text/javascript"}}],"protocolProfileBehavior":{"disableBodyPruning":true}},{"name":"查询出库单聚合状态","request":{"method":"POST","url":"https://api.xlwms.com/openapi/v1/outboundOrder/selectBizStatus","header":[{"key":"Content-Type","value":"application/json"}],"body":{"mode":"raw","raw":"{\n    \"appKey\": \"b80bf9a79fba4efd9fe7a1ffd8591116\",\n    \"data\": {\n        \"outboundOrderNoList\": [\n            \"OB06922052500O\",\n            \"OB06922052500P\"\n        ]\n    },\n    \"reqTime\": \"1653277618\"\n}","options":{"raw":{"language":"json"}}}},"events":[{"listen":"prerequest","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        // 引入加密库\r\nconst CryptoJS = require('crypto-js');\r\n\r\n// 配置参数\r\nconst appKey = \"816ad7a730484c4596cafb1e42371218\";\r\nconst appSecret = \"fc34184c6350441ba1a5509d74b32d39\";\r\n\r\n// 生成当前秒级时间戳\r\nconst reqTime = Math.floor(Date.now() / 1000);\r\n\r\n// 设置 reqTime 到环境变量\r\npm.environment.set(\"reqTime\", reqTime);\r\n\r\n// 获取并更新请求体数据 - 只更新 reqTime，不修改 data\r\nfunction getAndUpdateRequestBody() {\r\n    try {\r\n        // 获取原始请求体\r\n        const rawBody = pm.request.body?.raw;\r\n        let requestBody = {};\r\n        \r\n        if (rawBody) {\r\n            requestBody = JSON.parse(rawBody);\r\n        }\r\n        \r\n        // 只更新顶层的 reqTime 字段，不修改 data 内的内容\r\n        requestBody.reqTime = reqTime;\r\n        \r\n        // 更新请求体\r\n        pm.request.body.update(JSON.stringify(requestBody, null, 2));\r\n        \r\n        console.log(\"更新后的请求体:\", JSON.stringify(requestBody, null, 2));\r\n        \r\n        return requestBody;\r\n    } catch (e) {\r\n        console.error(\"处理请求体时出错:\", e);\r\n        return { reqTime: reqTime };\r\n    }\r\n}\r\n\r\n// 递归对对象的所有属性按字典序排序（不区分大小写）\r\nfunction sortObjectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        // 如果是数组，对每个元素进行排序\r\n        return obj.map(item => sortObjectKeys(item));\r\n    } else if (obj && typeof obj === 'object') {\r\n        // 如果是对象，对键进行排序并递归处理值\r\n        const sortedKeys = Object.keys(obj).sort((a, b) => {\r\n            return a.toLowerCase().localeCompare(b.toLowerCase());\r\n        });\r\n        \r\n        const sortedObj = {};\r\n        sortedKeys.forEach(key => {\r\n            sortedObj[key] = sortObjectKeys(obj[key]);\r\n        });\r\n        \r\n        return sortedObj;\r\n    }\r\n    \r\n    // 基本类型直接返回\r\n    return obj;\r\n}\r\n\r\n// 处理 data 数据 - 如果有值则按字典序排序，否则使用 {}\r\nfunction processData(requestBody) {\r\n    // 检查 data 是否存在且有值\r\n    if (requestBody.data && \r\n        (Array.isArray(requestBody.data) && requestBody.data.length > 0) ||\r\n        (typeof requestBody.data === 'object' && Object.keys(requestBody.data).length > 0)) {\r\n        \r\n        // 对 data 进行深度排序\r\n        const sortedData = sortObjectKeys(requestBody.data);\r\n        \r\n        // 将排序后的 data 对象转换为字符串\r\n        const dataStr = JSON.stringify(sortedData);\r\n        console.log(\"排序后的 data:\", dataStr);\r\n        \r\n        return dataStr;\r\n    } else {\r\n        // data 为空或不存在，使用 {}\r\n        console.log(\"data 为空，使用 {}\");\r\n        return \"{}\";\r\n    }\r\n}\r\n\r\n// 生成 authcode 的主函数\r\nfunction generateAuthCode(dataStr) {\r\n    // 构建待加密字符串: appKey + data + reqTime\r\n    const signString = appKey + dataStr + reqTime.toString();\r\n    console.log(\"最终待加密字符串:\", signString);\r\n    \r\n    // 使用 appSecret 作为密钥进行 HMAC-SHA256 加密\r\n    const authCode = CryptoJS.HmacSHA256(signString, appSecret).toString(CryptoJS.enc.Hex);\r\n    console.log(\"生成的 authCode:\", authCode);\r\n    \r\n    return authCode;\r\n}\r\n\r\n// 解析 URL 的辅助函数（兼容 Apifox 环境）\r\nfunction parseUrl(urlString) {\r\n    // 简单的 URL 解析函数，用于 Apifox 环境\r\n    const urlMatch = urlString.match(/(https?:\\/\\/[^\\/]+)(\\/.*)?/);\r\n    if (!urlMatch) {\r\n        throw new Error('Invalid URL format');\r\n    }\r\n    \r\n    const baseUrl = urlMatch[1];\r\n    const pathAndQuery = urlMatch[2] || '';\r\n    \r\n    // 分离路径和查询参数\r\n    const pathQueryMatch = pathAndQuery.split('?');\r\n    const path = pathQueryMatch[0] || '';\r\n    const queryString = pathQueryMatch[1] || '';\r\n    \r\n    // 解析查询参数\r\n    const queryParams = {};\r\n    if (queryString) {\r\n        queryString.split('&').forEach(param => {\r\n            const [key, value] = param.split('=');\r\n            if (key) {\r\n                queryParams[decodeURIComponent(key)] = decodeURIComponent(value || '');\r\n            }\r\n        });\r\n    }\r\n    \r\n    return {\r\n        baseUrl,\r\n        path,\r\n        queryParams\r\n    };\r\n}\r\n\r\n// 构建 URL 的辅助函数\r\nfunction buildUrl(baseUrl, path, queryParams) {\r\n    let url = baseUrl + path;\r\n    \r\n    const queryString = Object.keys(queryParams)\r\n        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)\r\n        .join('&');\r\n    \r\n    if (queryString) {\r\n        url += '?' + queryString;\r\n    }\r\n    \r\n    return url;\r\n}\r\n\r\n// 主执行逻辑\r\ntry {\r\n    // 获取并更新请求体（只更新 reqTime）\r\n    const requestBody = getAndUpdateRequestBody();\r\n    \r\n    // 处理 data 数据\r\n    const dataStr = processData(requestBody);\r\n    \r\n    // 生成 authcode\r\n    const authCode = generateAuthCode(dataStr);\r\n    \r\n    // 设置环境变量\r\n    pm.environment.set(\"authCode\", authCode);\r\n    \r\n    // 关键修复：使用兼容 Apifox 的 URL 处理方法\r\n    const currentUrlString = pm.request.url.toString();\r\n    console.log(\"原始 URL:\", currentUrlString);\r\n    \r\n    // 解析当前 URL\r\n    const urlParts = parseUrl(currentUrlString);\r\n    \r\n    // 添加或更新 authcode 参数\r\n    urlParts.queryParams.authcode = authCode;\r\n    \r\n    // 构建新的 URL\r\n    const newUrl = buildUrl(urlParts.baseUrl, urlParts.path, urlParts.queryParams);\r\n    \r\n    // 更新请求 URL\r\n    pm.request.url = newUrl;\r\n    \r\n    console.log(\"=== authcode 生成完成 ===\");\r\n    console.log(\"新生成的 reqTime:\", reqTime);\r\n    console.log(\"处理后的 data:\", dataStr);\r\n    console.log(\"authCode:\", authCode);\r\n    console.log(\"目标 URL:\", newUrl);\r\n    \r\n} catch (error) {\r\n    console.error(\"生成 authcode 时出错:\", error);\r\n    // 提供更详细的错误信息\r\n    console.error(\"错误堆栈:\", error.stack);\r\n}\n      "],"type":"text/javascript"}}],"protocolProfileBehavior":{"disableBodyPruning":true}}],"variable":[{"key":"timestamp","value":"1761034276","type":"string"},{"key":"signature","value":"d1ba349b26877423253b0c8bb665560e8db068dd648581dbeef91113f222605c","type":"string"},{"key":"shipber_client_id","value":"506f8e5308f2344ecd48f5f1ae38ad53","type":"string"},{"key":"shipber_client_secret","value":"1e880198b085f847b5582938fa4ad603","type":"string"},{"key":"reqTime","value":1761880588,"type":"string"},{"key":"authCode","value":"0a825517957ae04b5472454c82bd6996f74a0ebc9e0a7a254b17ec835f334881","type":"string"},{"key":"url","value":"https://api.xlwms.com/fc34184c6350441ba1a5509d74b32d39","type":"string"},{"key":"BASE_URL","value":"","type":"string"}]}