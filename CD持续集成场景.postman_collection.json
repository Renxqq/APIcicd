{"info":{"_postman_id":"bae007ce-4708-427f-ada1-89d7fde7296b","name":"TestCI/CD持续集成场景","schema":"https://schema.getpostman.com/json/collection/v2.1.0/collection.json"},"item":[{"name":"创建订单接口","request":{"method":"POST","url":"https://api.xlwms.com/openapi/v1/outboundOrder/create","header":[{"key":"Content-Type","value":"application/json"}],"body":{"mode":"raw","raw":"{\n\t\"appKey\": \"816ad7a730484c4596cafb1e42371218\",\n\t\"data\": [{\n\t\t\"subOrderType\": 1,\n\t\t\"receiver\": \"Angel Hurt\",\n\t\t\"logisticsChannel\": \"ZITI-FedEx\",\n\t\t\"provinceCode\": \"MO\",\n\t\t\"countryRegionCode\": \"US\",\n\t\t\"thirdOrderNo\": \"ZKMC-251027-0107\",\n\t\t\"cityName\": \"CALIFORNIA\",\n\t\t\"countryRegionName\": \"United States of America (USA)\",\n\t\t\"whCode\": \"USCA02\",\n\t\t\"postCode\": \"65018\",\n\t\t\"provinceName\": \"The Show Me State\",\n\t\t\"addressOne\": \"806 W VERSAILLES AVE\",\n\t\t\"productList\": [{\n\t\t\t\"quantity\": 1,\n\t\t\t\"sku\": \"ZKMC-KCDLJV0000000001\",\n\t\t\t\"productName\": \"卡车吊鹿架\"\n\t\t}]\n\t}],\n\t\"reqTime\": \"{{reqtime}}\"\n}","options":{"raw":{"language":"json"}}}},"events":[{"listen":"prerequest","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        // 引入加密库\r\nconst CryptoJS = require('crypto-js');\r\n\r\n// 配置参数\r\nconst appKey = \"816ad7a730484c4596cafb1e42371218\";\r\nconst appSecret = \"fc34184c6350441ba1a5509d74b32d39\";\r\n\r\n// 生成当前秒级时间戳\r\nconst reqTime = Math.floor(Date.now() / 1000);\r\n\r\n// 设置 reqTime 到环境变量\r\npm.environment.set(\"reqTime\", reqTime);\r\n\r\n// 获取并更新请求体数据 - 只更新 reqTime，不修改 data\r\nfunction getAndUpdateRequestBody() {\r\n    try {\r\n        // 获取原始请求体\r\n        const rawBody = pm.request.body?.raw;\r\n        let requestBody = {};\r\n        \r\n        if (rawBody) {\r\n            requestBody = JSON.parse(rawBody);\r\n        }\r\n        \r\n        // 只更新顶层的 reqTime 字段，不修改 data 内的内容\r\n        requestBody.reqTime = reqTime;\r\n        \r\n        // 更新请求体\r\n        pm.request.body.update(JSON.stringify(requestBody, null, 2));\r\n        \r\n        console.log(\"更新后的请求体:\", JSON.stringify(requestBody, null, 2));\r\n        \r\n        return requestBody;\r\n    } catch (e) {\r\n        console.error(\"处理请求体时出错:\", e);\r\n        return { reqTime: reqTime };\r\n    }\r\n}\r\n\r\n// 递归对对象的所有属性按字典序排序（不区分大小写）\r\nfunction sortObjectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        // 如果是数组，对每个元素进行排序\r\n        return obj.map(item => sortObjectKeys(item));\r\n    } else if (obj && typeof obj === 'object') {\r\n        // 如果是对象，对键进行排序并递归处理值\r\n        const sortedKeys = Object.keys(obj).sort((a, b) => {\r\n            return a.toLowerCase().localeCompare(b.toLowerCase());\r\n        });\r\n        \r\n        const sortedObj = {};\r\n        sortedKeys.forEach(key => {\r\n            sortedObj[key] = sortObjectKeys(obj[key]);\r\n        });\r\n        \r\n        return sortedObj;\r\n    }\r\n    \r\n    // 基本类型直接返回\r\n    return obj;\r\n}\r\n\r\n// 处理 data 数据 - 如果有值则按字典序排序，否则使用 {}\r\nfunction processData(requestBody) {\r\n    // 检查 data 是否存在且有值\r\n    if (requestBody.data && \r\n        (Array.isArray(requestBody.data) && requestBody.data.length > 0) ||\r\n        (typeof requestBody.data === 'object' && Object.keys(requestBody.data).length > 0)) {\r\n        \r\n        // 对 data 进行深度排序\r\n        const sortedData = sortObjectKeys(requestBody.data);\r\n        \r\n        // 将排序后的 data 对象转换为字符串\r\n        const dataStr = JSON.stringify(sortedData);\r\n        console.log(\"排序后的 data:\", dataStr);\r\n        \r\n        return dataStr;\r\n    } else {\r\n        // data 为空或不存在，使用 {}\r\n        console.log(\"data 为空，使用 {}\");\r\n        return \"{}\";\r\n    }\r\n}\r\n\r\n// 生成 authcode 的主函数\r\nfunction generateAuthCode(dataStr) {\r\n    // 构建待加密字符串: appKey + data + reqTime\r\n    const signString = appKey + dataStr + reqTime.toString();\r\n    console.log(\"最终待加密字符串:\", signString);\r\n    \r\n    // 使用 appSecret 作为密钥进行 HMAC-SHA256 加密\r\n    const authCode = CryptoJS.HmacSHA256(signString, appSecret).toString(CryptoJS.enc.Hex);\r\n    console.log(\"生成的 authCode:\", authCode);\r\n    \r\n    return authCode;\r\n}\r\n\r\n// 解析 URL 的辅助函数（兼容 Apifox 环境）\r\nfunction parseUrl(urlString) {\r\n    // 简单的 URL 解析函数，用于 Apifox 环境\r\n    const urlMatch = urlString.match(/(https?:\\/\\/[^\\/]+)(\\/.*)?/);\r\n    if (!urlMatch) {\r\n        throw new Error('Invalid URL format');\r\n    }\r\n    \r\n    const baseUrl = urlMatch[1];\r\n    const pathAndQuery = urlMatch[2] || '';\r\n    \r\n    // 分离路径和查询参数\r\n    const pathQueryMatch = pathAndQuery.split('?');\r\n    const path = pathQueryMatch[0] || '';\r\n    const queryString = pathQueryMatch[1] || '';\r\n    \r\n    // 解析查询参数\r\n    const queryParams = {};\r\n    if (queryString) {\r\n        queryString.split('&').forEach(param => {\r\n            const [key, value] = param.split('=');\r\n            if (key) {\r\n                queryParams[decodeURIComponent(key)] = decodeURIComponent(value || '');\r\n            }\r\n        });\r\n    }\r\n    \r\n    return {\r\n        baseUrl,\r\n        path,\r\n        queryParams\r\n    };\r\n}\r\n\r\n// 构建 URL 的辅助函数\r\nfunction buildUrl(baseUrl, path, queryParams) {\r\n    let url = baseUrl + path;\r\n    \r\n    const queryString = Object.keys(queryParams)\r\n        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)\r\n        .join('&');\r\n    \r\n    if (queryString) {\r\n        url += '?' + queryString;\r\n    }\r\n    \r\n    return url;\r\n}\r\n\r\n// 主执行逻辑\r\ntry {\r\n    // 获取并更新请求体（只更新 reqTime）\r\n    const requestBody = getAndUpdateRequestBody();\r\n    \r\n    // 处理 data 数据\r\n    const dataStr = processData(requestBody);\r\n    \r\n    // 生成 authcode\r\n    const authCode = generateAuthCode(dataStr);\r\n    \r\n    // 设置环境变量\r\n    pm.environment.set(\"authCode\", authCode);\r\n    \r\n    // 关键修复：使用兼容 Apifox 的 URL 处理方法\r\n    const currentUrlString = pm.request.url.toString();\r\n    console.log(\"原始 URL:\", currentUrlString);\r\n    \r\n    // 解析当前 URL\r\n    const urlParts = parseUrl(currentUrlString);\r\n    \r\n    // 添加或更新 authcode 参数\r\n    urlParts.queryParams.authcode = authCode;\r\n    \r\n    // 构建新的 URL\r\n    const newUrl = buildUrl(urlParts.baseUrl, urlParts.path, urlParts.queryParams);\r\n    \r\n    // 更新请求 URL\r\n    pm.request.url = newUrl;\r\n    \r\n    console.log(\"=== authcode 生成完成 ===\");\r\n    console.log(\"新生成的 reqTime:\", reqTime);\r\n    console.log(\"处理后的 data:\", dataStr);\r\n    console.log(\"authCode:\", authCode);\r\n    console.log(\"目标 URL:\", newUrl);\r\n    \r\n} catch (error) {\r\n    console.error(\"生成 authcode 时出错:\", error);\r\n    // 提供更详细的错误信息\r\n    console.error(\"错误堆栈:\", error.stack);\r\n}\n      "],"type":"text/javascript"}},{"listen":"test","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        \n      async function ____replaceIn(value) {\n        if (typeof pm.variables.replaceInAsync === 'function') {\n          return await pm.variables.replaceInAsync(value);\n        }\n        return pm.variables.replaceIn(value);\n      };\n      ;(async () => {\n        try{\n          \n          const expression = pm.variables.replaceIn(`$.data[0].orderNo`);\n          const JSONPath = require('jsonpath-plus').JSONPath;\n          const jsonData = pm.response.json();\n          let value = JSONPath({\n            json: jsonData,\n            path: expression,\n            wrap: false\n          });\n\n\n          if (false && undefined !== undefined) {\n            if (Array.isArray(value)) {\n              value = Number(undefined) >= 0 ? value[undefined] : value[value.length + Number(undefined)];\n            } else {\n              value = undefined;\n            }\n          }\n          \n          \n        switch (typeof value) {\n          case 'object':\n            value = JSON.stringify(value);\n            break;\n          default:\n            value = String(value);\n            break;\n        }\n      \n          const formattedName = await ____replaceIn(`orderNo`);pm.environment.set(formattedName, value);console.log('___label_placeholder__processor___', '已设置环境变量【' + formattedName + '】，值为' + ' ' + '【' + value + '】')\n        } catch(e) {\n          e.message = `提取变量【orderNo】出错: ` + e.message;\n          setImmediate(() => { throw e });\n        }\n      })();\n      "],"type":"text/javascript"}}],"protocolProfileBehavior":{"disableBodyPruning":true}},{"name":"delay","item":[]},{"name":"取消/截单小包出库单","request":{"method":"POST","url":"https://api.xlwms.com/openapi/v1/outboundOrder/cancel","header":[{"key":"Content-Type","value":"application/json"}],"body":{"mode":"raw","raw":"{\n    \"appKey\": \"816ad7a730484c4596cafb1e42371218\",\n    \"reqTime\": \"{{reqTime}}\",\n    \"data\": [],\n    \"outboundOrderNoList\": [\n        \"{{orderNo}}\"\n    ]\n}","options":{"raw":{"language":"json"}}}},"events":[{"listen":"prerequest","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        const CryptoJS = require('crypto-js');\r\n\r\nconst appKey = \"816ad7a730484c4596cafb1e42371218\";\r\nconst appSecret = \"fc34184c6350441ba1a5509d74b32d39\";\r\nconst reqTime = Math.floor(Date.now() / 1000);\r\n\r\n// 手动获取环境变量值\r\nconst orderNo = pm.environment.get(\"orderNo\");\r\nconsole.log(\"获取到的订单号:\", orderNo);\r\n\r\nif (!orderNo) {\r\n    console.error(\"❌ orderNo环境变量未定义，请先执行建单接口\");\r\n    return;\r\n}\r\n\r\n// 设置环境变量\r\npm.environment.set(\"reqTime\", reqTime.toString());\r\n\r\n// 手动构建完整的请求体（使用实际值）\r\nconst requestBody = {\r\n    \"appKey\": appKey,\r\n    \"reqTime\": reqTime.toString(),\r\n    \"data\": {\r\n        \"outboundOrderNoList\": [orderNo]  // 使用实际值，不是模板\r\n    }\r\n};\r\n\r\nconsole.log(\"手动构建的请求体:\", JSON.stringify(requestBody, null, 2));\r\n\r\n// 更新请求体\r\npm.request.body.update({\r\n    mode: 'raw',\r\n    raw: JSON.stringify(requestBody)\r\n});\r\n\r\n// 定义排序函数\r\nfunction sortObjectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        // 如果是数组，保持原顺序，只对数组中的对象元素排序\r\n        return obj.map(item => {\r\n            if (item && typeof item === 'object' && !Array.isArray(item)) {\r\n                return sortObjectKeys(item);\r\n            }\r\n            return item;\r\n        });\r\n    } else if (obj && typeof obj === 'object') {\r\n        // 对对象的键进行排序\r\n        const sortedKeys = Object.keys(obj).sort((a, b) => {\r\n            return a.toLowerCase().localeCompare(b.toLowerCase());\r\n        });\r\n        \r\n        const sortedObj = {};\r\n        sortedKeys.forEach(key => {\r\n            sortedObj[key] = sortObjectKeys(obj[key]);\r\n        });\r\n        \r\n        return sortedObj;\r\n    }\r\n    \r\n    return obj;\r\n}\r\n\r\n// 处理 data 数据\r\nconst sortedData = sortObjectKeys(requestBody.data);\r\nconst dataStr = JSON.stringify(sortedData);\r\nconst signString = appKey + dataStr + reqTime.toString();\r\nconsole.log(\"待加密字符串:\", signString);\r\n\r\nconst authCode = CryptoJS.HmacSHA256(signString, appSecret).toString(CryptoJS.enc.Hex);\r\nconsole.log(\"生成的 authCode:\", authCode);\r\n\r\n// 使用 Apifox 兼容的方式更新URL\r\n// 获取当前URL\r\nconst currentUrl = pm.request.url.toString();\r\nconsole.log(\"原始URL:\", currentUrl);\r\n\r\n// 解析URL并添加authcode参数\r\nlet urlObj;\r\ntry {\r\n    // 尝试使用URL构造函数（某些环境下可能不可用）\r\n    urlObj = new URL(currentUrl);\r\n} catch (e) {\r\n    // 如果URL构造函数不可用，使用字符串处理方法\r\n    console.log(\"URL构造函数不可用，使用字符串处理方法\");\r\n    \r\n    // 分离基础URL和查询参数\r\n    const urlParts = currentUrl.split('?');\r\n    const baseUrl = urlParts[0];\r\n    let queryString = urlParts[1] || '';\r\n    \r\n    // 处理查询参数\r\n    let queryParams = {};\r\n    if (queryString) {\r\n        queryString.split('&').forEach(param => {\r\n            const [key, value] = param.split('=');\r\n            if (key) {\r\n                queryParams[key] = value || '';\r\n            }\r\n        });\r\n    }\r\n    \r\n    // 添加或更新authcode参数\r\n    queryParams.authcode = authCode;\r\n    \r\n    // 重新构建查询字符串\r\n    const newQueryString = Object.keys(queryParams)\r\n        .map(key => `${key}=${encodeURIComponent(queryParams[key])}`)\r\n        .join('&');\r\n    \r\n    // 构建完整URL\r\n    const newUrl = baseUrl + (newQueryString ? '?' + newQueryString : '');\r\n    pm.request.url = newUrl;\r\n    console.log(\"最终URL:\", newUrl);\r\n}\r\n\r\n// 如果URL构造函数可用，使用它\r\nif (urlObj) {\r\n    urlObj.searchParams.set('authcode', authCode);\r\n    pm.request.url = urlObj.toString();\r\n    console.log(\"最终URL:\", urlObj.toString());\r\n}\r\n\r\nconsole.log(\"=== 前置脚本执行完成 ===\");\n      "],"type":"text/javascript"}}],"protocolProfileBehavior":{"disableBodyPruning":true}},{"name":"查询出库单聚合状态","request":{"method":"POST","url":"https://api.xlwms.com/openapi/v1/outboundOrder/selectBizStatus","header":[{"key":"Content-Type","value":"application/json"}],"body":{"mode":"raw","raw":"{\n    \"appKey\": \"b80bf9a79fba4efd9fe7a1ffd8591116\",\n    \"data\": {\n        \"outboundOrderNoList\": [\n            \"{{orderNo}}\"\n        ]\n    },\n    \"reqTime\": \"{{reqTime}}\"\n}","options":{"raw":{"language":"json"}}}},"events":[{"listen":"prerequest","script":{"exec":["\n        if (JSON.setEnableBigInt) {\n          JSON.setEnableBigInt(undefined);\n        }\n        const CryptoJS = require('crypto-js');\r\n\r\nconst appKey = \"816ad7a730484c4596cafb1e42371218\";\r\nconst appSecret = \"fc34184c6350441ba1a5509d74b32d39\";\r\nconst reqTime = Math.floor(Date.now() / 1000);\r\n\r\n// 手动获取环境变量值\r\nconst orderNo = pm.environment.get(\"orderNo\");\r\nconsole.log(\"获取到的订单号:\", orderNo);\r\n\r\nif (!orderNo) {\r\n    console.error(\"❌ orderNo环境变量未定义，请先执行建单接口\");\r\n    return;\r\n}\r\n\r\n// 设置环境变量\r\npm.environment.set(\"reqTime\", reqTime.toString());\r\n\r\n// 手动构建完整的请求体（使用实际值）\r\nconst requestBody = {\r\n    \"appKey\": appKey,\r\n    \"reqTime\": reqTime.toString(),\r\n    \"data\": {\r\n        \"outboundOrderNoList\": [orderNo]  // 使用实际值，不是模板\r\n    }\r\n};\r\n\r\nconsole.log(\"手动构建的请求体:\", JSON.stringify(requestBody, null, 2));\r\n\r\n// 更新请求体\r\npm.request.body.update({\r\n    mode: 'raw',\r\n    raw: JSON.stringify(requestBody)\r\n});\r\n\r\n// 定义排序函数\r\nfunction sortObjectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        // 如果是数组，保持原顺序，只对数组中的对象元素排序\r\n        return obj.map(item => {\r\n            if (item && typeof item === 'object' && !Array.isArray(item)) {\r\n                return sortObjectKeys(item);\r\n            }\r\n            return item;\r\n        });\r\n    } else if (obj && typeof obj === 'object') {\r\n        // 对对象的键进行排序\r\n        const sortedKeys = Object.keys(obj).sort((a, b) => {\r\n            return a.toLowerCase().localeCompare(b.toLowerCase());\r\n        });\r\n        \r\n        const sortedObj = {};\r\n        sortedKeys.forEach(key => {\r\n            sortedObj[key] = sortObjectKeys(obj[key]);\r\n        });\r\n        \r\n        return sortedObj;\r\n    }\r\n    \r\n    return obj;\r\n}\r\n\r\n// 处理 data 数据\r\nconst sortedData = sortObjectKeys(requestBody.data);\r\nconst dataStr = JSON.stringify(sortedData);\r\nconst signString = appKey + dataStr + reqTime.toString();\r\nconsole.log(\"待加密字符串:\", signString);\r\n\r\nconst authCode = CryptoJS.HmacSHA256(signString, appSecret).toString(CryptoJS.enc.Hex);\r\nconsole.log(\"生成的 authCode:\", authCode);\r\n\r\n// 使用 Apifox 兼容的方式更新URL\r\n// 获取当前URL\r\nconst currentUrl = pm.request.url.toString();\r\nconsole.log(\"原始URL:\", currentUrl);\r\n\r\n// 解析URL并添加authcode参数\r\nlet urlObj;\r\ntry {\r\n    // 尝试使用URL构造函数（某些环境下可能不可用）\r\n    urlObj = new URL(currentUrl);\r\n} catch (e) {\r\n    // 如果URL构造函数不可用，使用字符串处理方法\r\n    console.log(\"URL构造函数不可用，使用字符串处理方法\");\r\n    \r\n    // 分离基础URL和查询参数\r\n    const urlParts = currentUrl.split('?');\r\n    const baseUrl = urlParts[0];\r\n    let queryString = urlParts[1] || '';\r\n    \r\n    // 处理查询参数\r\n    let queryParams = {};\r\n    if (queryString) {\r\n        queryString.split('&').forEach(param => {\r\n            const [key, value] = param.split('=');\r\n            if (key) {\r\n                queryParams[key] = value || '';\r\n            }\r\n        });\r\n    }\r\n    \r\n    // 添加或更新authcode参数\r\n    queryParams.authcode = authCode;\r\n    \r\n    // 重新构建查询字符串\r\n    const newQueryString = Object.keys(queryParams)\r\n        .map(key => `${key}=${encodeURIComponent(queryParams[key])}`)\r\n        .join('&');\r\n    \r\n    // 构建完整URL\r\n    const newUrl = baseUrl + (newQueryString ? '?' + newQueryString : '');\r\n    pm.request.url = newUrl;\r\n    console.log(\"最终URL:\", newUrl);\r\n}\r\n\r\n// 如果URL构造函数可用，使用它\r\nif (urlObj) {\r\n    urlObj.searchParams.set('authcode', authCode);\r\n    pm.request.url = urlObj.toString();\r\n    console.log(\"最终URL:\", urlObj.toString());\r\n}\r\n\r\nconsole.log(\"=== 前置脚本执行完成 ===\");\n      "],"type":"text/javascript"}}],"protocolProfileBehavior":{"disableBodyPruning":true}}],"variable":[{"key":"timestamp","value":"1761034276","type":"string"},{"key":"signature","value":"d1ba349b26877423253b0c8bb665560e8db068dd648581dbeef91113f222605c","type":"string"},{"key":"shipber_client_id","value":"506f8e5308f2344ecd48f5f1ae38ad53","type":"string"},{"key":"shipber_client_secret","value":"1e880198b085f847b5582938fa4ad603","type":"string"},{"key":"reqTime","value":"1762419053","type":"string"},{"key":"authCode","value":"29fcfedbfe1b0899f064f066f8f1efdf5b40848951c5a796ca00ca612b47af14","type":"string"},{"key":"orderNo","value":"OBS0852511060TV","type":"string"},{"key":"url","value":"https://api.xlwms.com/fc34184c6350441ba1a5509d74b32d39","type":"string"},{"key":"BASE_URL","value":"","type":"string"}]}